
#include "ANNarchy.h"

#include <sched.h>


/*
 * Internal data
 *
 */
double dt;
long int t;
std::vector<std::mt19937> rng;

// Custom constants


// Populations
PopStruct0 pop0;
PopStruct1 pop1;


// Projections
ProjStruct0 proj0;
ProjStruct1 proj1;


// Global operations


// Recorders
std::vector<Monitor*> recorders;
int addRecorder(Monitor* recorder){
    int found = -1;

    for (unsigned int i=0; i<recorders.size(); i++) {
        if (recorders[i] == nullptr) {
            found = i;
            break;
        }
    }

    if (found != -1) {
        // fill a previously cleared slot
        recorders[found] = recorder;
        return found;
    } else {
        recorders.push_back(recorder);
        return recorders.size() - 1;
    }
}
Monitor* getRecorder(int id) {
    if (id < recorders.size())
        return recorders[id];
    else
        return nullptr;
}
void removeRecorder(Monitor* recorder){
    for (unsigned int i=0; i<recorders.size(); i++){
        if(recorders[i] == recorder){
            recorders[i] = nullptr;
            break;
        }
    }
}

void singleStep(int, int); // Function prototype

// Simulate the network for the given number of steps,
// called from python
void run(int nbSteps) {


    #pragma omp parallel
    {
        int tid = omp_get_thread_num();
        int nt = omp_get_max_threads();

        for(int i=0; i<nbSteps; i++) {
            singleStep(tid, nt);
        }
    }


}

// Simulate the network for a single steps,
// called from python
void step() {

    #pragma omp parallel
    {
        int tid = omp_get_thread_num();
        int nt = omp_get_max_threads();

        singleStep(tid, nt);
    }

}

int run_until(int steps, std::vector<int> populations, bool or_and)
{


    run(steps);
    return steps;


}

// Initialize the internal data and the random numbers generator
void initialize(double _dt) {


    // Internal variables
    dt = _dt;
    t = (long int)(0);

    // Populations
    // Initialize populations
    pop0.init_population();
    pop1.init_population();


    // Projections
    // Initialize projections
    proj0.init_projection();
    proj1.init_projection();


    // Custom constants


}

// Initialize the random distribution objects
void init_rng_dist() {
pop0.init_rng_dist();
pop1.init_rng_dist();

}

// Change the seed of the RNG
void setSeed(long int seed, int num_sources, bool use_seed_seq){
#ifdef _DEBUG
    std::cout << "setSeed(): " << seed << ", " << num_sources << ", " << std::string((use_seed_seq) ? "true" : "false") << std::endl;
#endif
    rng.clear();

    if (num_sources == 1) {
        rng.push_back(std::mt19937(seed));
    } else {
        if (use_seed_seq) {
            std::seed_seq seq{seed};
            std::vector<std::uint32_t> seeds(num_sources);
            seq.generate(seeds.begin(), seeds.end());

            for (auto it = seeds.begin(); it != seeds.end(); it++) {
                rng.push_back(std::mt19937(*it));
            }
        } else {
            // Seeding comparable to the NEST framework 2.20
            // source: https://nest-simulator.readthedocs.io/en/stable/guides/random_numbers.html
            // Last access (12th april 2021)

            for (int i = 0; i < num_sources; i++) {
                // technically we could leave out num_sources here, as it is the
                // init of the Python seeds in the NEST framework
                long int s = seed + num_sources + i + 1;

                rng.push_back(std::mt19937(s));
            }
        }
    }

    rng.shrink_to_fit();
}

// Step method. Generated by ANNarchy.
void singleStep(int tid, int nt)
{


    ////////////////////////////////
    // Presynaptic events
    ////////////////////////////////


    // pop1: pop1
    #pragma omp single nowait
    {
        if (pop1._active)
            memset( pop1._sum_exc.data(), 0.0, pop1._sum_exc.size() * sizeof(double));
    }

    // pop1: pop1
    #pragma omp single nowait
    {
        if (pop1._active)
            memset( pop1._sum_in.data(), 0.0, pop1._sum_in.size() * sizeof(double));
    }
    #pragma omp barrier
    
#ifdef _TRACE_SIMULATION_STEPS
    std::cout << "Update psp/conductances ..." << std::endl;
#endif
    proj0.compute_psp();
    proj1.compute_psp();


    #pragma omp barrier


    ////////////////////////////////
    // Recording target variables
    ////////////////////////////////
#ifdef _TRACE_SIMULATION_STEPS
    std::cout << "Record psp/conductances ..." << std::endl;
#endif
    for (unsigned int i=tid; i < recorders.size(); i += nt) {
        recorders[i]->record_targets();
    }

    ////////////////////////////////
    // Update random distributions
    ////////////////////////////////
#ifdef _TRACE_SIMULATION_STEPS
    std::cout << "Draw required random numbers ..." << std::endl;
#endif

    pop1.update_rng(tid);



    ////////////////////////////////
    // Update neural variables
    ////////////////////////////////
#ifdef _TRACE_SIMULATION_STEPS
    std::cout << "Evaluate neural ODEs ..." << std::endl;
#endif

    pop1.update(tid);



    #pragma omp barrier

    ////////////////////////////////
    // Delay outputs
    ////////////////////////////////
#ifdef _TRACE_SIMULATION_STEPS
    std::cout << "Update delay queues ..." << std::endl;
#endif


    ////////////////////////////////
    // Global operations (min/max/mean)
    ////////////////////////////////
#ifdef _TRACE_SIMULATION_STEPS
    std::cout << "Update global operations ..." << std::endl;
#endif




    ////////////////////////////////
    // Update synaptic variables
    ////////////////////////////////
#ifdef _TRACE_SIMULATION_STEPS
    std::cout << "Evaluate synaptic ODEs ..." << std::endl;
#endif

    proj1.update_synapse(tid);



    #pragma omp barrier

    ////////////////////////////////
    // Postsynaptic events
    ////////////////////////////////


    ////////////////////////////////
    // Structural plasticity
    ////////////////////////////////


    ////////////////////////////////
    // Recording neural / synaptic variables
    ////////////////////////////////
    #pragma omp barrier


    for (unsigned int i=tid; i < recorders.size(); i += nt){
        recorders[i]->record();
    }


    #pragma omp barrier

    ////////////////////////////////
    // Increase internal time
    ////////////////////////////////
    #pragma omp single
    {
        t++;
    } // implicit barrier


}


/*
 * Access to time and dt
 *
*/
long int getTime() {return t;}
void setTime(long int t_) { t=t_;}
double getDt() { return dt;}
void setDt(double dt_) { dt=dt_;}

/*
 * Number of threads
 *
*/
void setNumberThreads(int threads, std::vector<int> core_list)
{

    // set worker set size
    omp_set_num_threads(threads);


    // set a cpu mask to prevent moving of threads
    cpu_set_t mask;

    // no CPUs selected
    CPU_ZERO(&mask);

    // no proc_bind
    for(auto it = core_list.begin(); it != core_list.end(); it++)
        CPU_SET(*it, &mask);
    const int set_result = sched_setaffinity(0, sizeof(cpu_set_t), &mask);
}
